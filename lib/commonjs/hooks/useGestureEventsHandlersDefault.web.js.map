{"version":3,"names":["INITIAL_CONTEXT","initialPosition","initialTranslationY","initialKeyboardState","KEYBOARD_STATE","UNDETERMINED","isScrollablePositionLocked","resetContext","context","Object","keys","map","key","undefined","useGestureEventsHandlersDefault","animatedPosition","animatedSnapPoints","animatedKeyboardState","animatedKeyboardHeight","animatedContainerHeight","animatedScrollableType","animatedHighestSnapPoint","animatedClosedPosition","animatedScrollableContentOffsetY","enableOverDrag","enablePanDownToClose","overDragResistanceFactor","isInTemporaryPosition","isScrollableRefreshable","animateToPosition","stopAnimation","useBottomSheetInternal","useSharedValue","handleOnStart","useWorkletCallback","__","translationY","value","handleOnChange","source","highestSnapPoint","SHOWN","lowestSnapPoint","GESTURE_SOURCE","CONTENT","negativeScrollableContentOffset","draggedPosition","accumulatedDraggedPosition","clampedPosition","clamp","HANDLE","SCROLLABLE_TYPE","VIEW","resistedPosition","Math","sqrt","handleOnEnd","absoluteY","velocityY","isSheetAtHighestSnapPoint","ANIMATION_SOURCE","GESTURE","isScrollable","Platform","OS","WINDOW_HEIGHT","runOnJS","Keyboard","dismiss","snapPoints","slice","unshift","destinationPoint","snapPoint","wasGestureHandledByScrollView","handleOnFinalize"],"sources":["useGestureEventsHandlersDefault.web.tsx"],"sourcesContent":["import { Keyboard, Platform } from 'react-native';\nimport {\n  runOnJS,\n  useSharedValue,\n  useWorkletCallback,\n} from 'react-native-reanimated';\nimport { useBottomSheetInternal } from './useBottomSheetInternal';\nimport {\n  ANIMATION_SOURCE,\n  GESTURE_SOURCE,\n  KEYBOARD_STATE,\n  SCROLLABLE_TYPE,\n  WINDOW_HEIGHT,\n} from '../constants';\nimport type { GestureEventHandlerCallbackType } from '../types';\nimport { clamp } from '../utilities/clamp';\nimport { snapPoint } from '../utilities/snapPoint';\n\ntype GestureEventContextType = {\n  initialPosition: number;\n  initialKeyboardState: KEYBOARD_STATE;\n  initialTranslationY: number;\n  isScrollablePositionLocked: boolean;\n};\n\nconst INITIAL_CONTEXT: GestureEventContextType = {\n  initialPosition: 0,\n  initialTranslationY: 0,\n  initialKeyboardState: KEYBOARD_STATE.UNDETERMINED,\n  isScrollablePositionLocked: false,\n};\n\nconst resetContext = (context: any) => {\n  'worklet';\n  Object.keys(context).map(key => {\n    context[key] = undefined;\n  });\n};\n\nexport const useGestureEventsHandlersDefault = () => {\n  //#region variables\n  const {\n    animatedPosition,\n    animatedSnapPoints,\n    animatedKeyboardState,\n    animatedKeyboardHeight,\n    animatedContainerHeight,\n    animatedScrollableType,\n    animatedHighestSnapPoint,\n    animatedClosedPosition,\n    animatedScrollableContentOffsetY,\n    enableOverDrag,\n    enablePanDownToClose,\n    overDragResistanceFactor,\n    isInTemporaryPosition,\n    isScrollableRefreshable,\n    animateToPosition,\n    stopAnimation,\n  } = useBottomSheetInternal();\n\n  const context = useSharedValue<GestureEventContextType>({\n    ...INITIAL_CONTEXT,\n  });\n  //#endregion\n\n  //#region gesture methods\n  const handleOnStart: GestureEventHandlerCallbackType = useWorkletCallback(\n    function handleOnStart(__, { translationY }) {\n      // cancel current animation\n      stopAnimation();\n\n      // store current animated position\n      context.value = {\n        ...context.value,\n        initialPosition: animatedPosition.value,\n        initialKeyboardState: animatedKeyboardState.value,\n        initialTranslationY: translationY,\n      };\n\n      /**\n       * if the scrollable content is scrolled, then\n       * we lock the position.\n       */\n      if (animatedScrollableContentOffsetY.value > 0) {\n        context.value.isScrollablePositionLocked = true;\n      }\n    },\n    [\n      stopAnimation,\n      animatedPosition,\n      animatedKeyboardState,\n      animatedScrollableContentOffsetY,\n    ]\n  );\n  const handleOnChange: GestureEventHandlerCallbackType = useWorkletCallback(\n    function handleOnChange(source, { translationY }) {\n      let highestSnapPoint = animatedHighestSnapPoint.value;\n\n      translationY = translationY - context.value.initialTranslationY;\n      /**\n       * if keyboard is shown, then we set the highest point to the current\n       * position which includes the keyboard height.\n       */\n      if (\n        isInTemporaryPosition.value &&\n        context.value.initialKeyboardState === KEYBOARD_STATE.SHOWN\n      ) {\n        highestSnapPoint = context.value.initialPosition;\n      }\n\n      /**\n       * if current position is out of provided `snapPoints` and smaller then\n       * highest snap pont, then we set the highest point to the current position.\n       */\n      if (\n        isInTemporaryPosition.value &&\n        context.value.initialPosition < highestSnapPoint\n      ) {\n        highestSnapPoint = context.value.initialPosition;\n      }\n\n      const lowestSnapPoint = enablePanDownToClose\n        ? animatedContainerHeight.value\n        : animatedSnapPoints.value[0];\n\n      /**\n       * if scrollable is refreshable and sheet position at the highest\n       * point, then do not interact with current gesture.\n       */\n      if (\n        source === GESTURE_SOURCE.CONTENT &&\n        isScrollableRefreshable.value &&\n        animatedPosition.value === highestSnapPoint\n      ) {\n        return;\n      }\n\n      /**\n       * a negative scrollable content offset to be subtracted from accumulated\n       * current position and gesture translation Y to allow user to drag the sheet,\n       * when scrollable position at the top.\n       * a negative scrollable content offset when the scrollable is not locked.\n       */\n      const negativeScrollableContentOffset =\n        (context.value.initialPosition === highestSnapPoint &&\n          source === GESTURE_SOURCE.CONTENT) ||\n        !context.value.isScrollablePositionLocked\n          ? animatedScrollableContentOffsetY.value * -1\n          : 0;\n\n      /**\n       * an accumulated value of starting position with gesture translation y.\n       */\n      const draggedPosition = context.value.initialPosition + translationY;\n\n      /**\n       * an accumulated value of dragged position and negative scrollable content offset,\n       * this will insure locking sheet position when user is scrolling the scrollable until,\n       * they reach to the top of the scrollable.\n       */\n      const accumulatedDraggedPosition =\n        draggedPosition + negativeScrollableContentOffset;\n\n      /**\n       * a clamped value of the accumulated dragged position, to insure keeping the dragged\n       * position between the highest and lowest snap points.\n       */\n      const clampedPosition = clamp(\n        accumulatedDraggedPosition,\n        highestSnapPoint,\n        lowestSnapPoint\n      );\n\n      /**\n       * if scrollable position is locked and the animated position\n       * reaches the highest point, then we unlock the scrollable position.\n       */\n      if (\n        context.value.isScrollablePositionLocked &&\n        source === GESTURE_SOURCE.CONTENT &&\n        animatedPosition.value === highestSnapPoint\n      ) {\n        context.value.isScrollablePositionLocked = false;\n      }\n\n      /**\n       * over-drag implementation.\n       */\n      if (enableOverDrag) {\n        if (\n          (source === GESTURE_SOURCE.HANDLE ||\n            animatedScrollableType.value === SCROLLABLE_TYPE.VIEW) &&\n          draggedPosition < highestSnapPoint\n        ) {\n          const resistedPosition =\n            highestSnapPoint -\n            Math.sqrt(1 + (highestSnapPoint - draggedPosition)) *\n              overDragResistanceFactor;\n          animatedPosition.value = resistedPosition;\n          return;\n        }\n\n        if (\n          source === GESTURE_SOURCE.HANDLE &&\n          draggedPosition > lowestSnapPoint\n        ) {\n          const resistedPosition =\n            lowestSnapPoint +\n            Math.sqrt(1 + (draggedPosition - lowestSnapPoint)) *\n              overDragResistanceFactor;\n          animatedPosition.value = resistedPosition;\n          return;\n        }\n\n        if (\n          source === GESTURE_SOURCE.CONTENT &&\n          draggedPosition + negativeScrollableContentOffset > lowestSnapPoint\n        ) {\n          const resistedPosition =\n            lowestSnapPoint +\n            Math.sqrt(\n              1 +\n                (draggedPosition +\n                  negativeScrollableContentOffset -\n                  lowestSnapPoint)\n            ) *\n              overDragResistanceFactor;\n          animatedPosition.value = resistedPosition;\n          return;\n        }\n      }\n\n      animatedPosition.value = clampedPosition;\n    },\n    [\n      enableOverDrag,\n      enablePanDownToClose,\n      overDragResistanceFactor,\n      isInTemporaryPosition,\n      isScrollableRefreshable,\n      animatedHighestSnapPoint,\n      animatedContainerHeight,\n      animatedSnapPoints,\n      animatedPosition,\n      animatedScrollableType,\n      animatedScrollableContentOffsetY,\n    ]\n  );\n  const handleOnEnd: GestureEventHandlerCallbackType = useWorkletCallback(\n    function handleOnEnd(source, { translationY, absoluteY, velocityY }) {\n      const highestSnapPoint = animatedHighestSnapPoint.value;\n      const isSheetAtHighestSnapPoint =\n        animatedPosition.value === highestSnapPoint;\n\n      /**\n       * if scrollable is refreshable and sheet position at the highest\n       * point, then do not interact with current gesture.\n       */\n      if (\n        source === GESTURE_SOURCE.CONTENT &&\n        isScrollableRefreshable.value &&\n        isSheetAtHighestSnapPoint\n      ) {\n        return;\n      }\n\n      /**\n       * if the sheet is in a temporary position and the gesture ended above\n       * the current position, then we snap back to the temporary position.\n       */\n      if (\n        isInTemporaryPosition.value &&\n        context.value.initialPosition >= animatedPosition.value\n      ) {\n        if (context.value.initialPosition > animatedPosition.value) {\n          animateToPosition(\n            context.value.initialPosition,\n            ANIMATION_SOURCE.GESTURE,\n            velocityY / 2\n          );\n        }\n        return;\n      }\n\n      /**\n       * close keyboard if current position is below the recorded\n       * start position and keyboard still shown.\n       */\n      const isScrollable =\n        animatedScrollableType.value !== SCROLLABLE_TYPE.UNDETERMINED &&\n        animatedScrollableType.value !== SCROLLABLE_TYPE.VIEW;\n\n      /**\n       * if keyboard is shown and the sheet is dragged down,\n       * then we dismiss the keyboard.\n       */\n      if (\n        context.value.initialKeyboardState === KEYBOARD_STATE.SHOWN &&\n        animatedPosition.value > context.value.initialPosition\n      ) {\n        /**\n         * if the platform is ios, current content is scrollable and\n         * the end touch point is below the keyboard position then\n         * we exit the method.\n         *\n         * because the the keyboard dismiss is interactive in iOS.\n         */\n        if (\n          !(\n            Platform.OS === 'ios' &&\n            isScrollable &&\n            absoluteY > WINDOW_HEIGHT - animatedKeyboardHeight.value\n          )\n        ) {\n          runOnJS(Keyboard.dismiss)();\n        }\n      }\n\n      /**\n       * reset isInTemporaryPosition value\n       */\n      if (isInTemporaryPosition.value) {\n        isInTemporaryPosition.value = false;\n      }\n\n      /**\n       * clone snap points array, and insert the container height\n       * if pan down to close is enabled.\n       */\n      const snapPoints = animatedSnapPoints.value.slice();\n      if (enablePanDownToClose) {\n        snapPoints.unshift(animatedClosedPosition.value);\n      }\n\n      /**\n       * calculate the destination point, using redash.\n       */\n      const destinationPoint = snapPoint(\n        translationY + context.value.initialPosition,\n        velocityY,\n        snapPoints\n      );\n\n      /**\n       * if destination point is the same as the current position,\n       * then no need to perform animation.\n       */\n      if (destinationPoint === animatedPosition.value) {\n        return;\n      }\n\n      const wasGestureHandledByScrollView =\n        source === GESTURE_SOURCE.CONTENT &&\n        animatedScrollableContentOffsetY.value > 0;\n      /**\n       * prevents snapping from top to middle / bottom with repeated interrupted scrolls\n       */\n      if (wasGestureHandledByScrollView && isSheetAtHighestSnapPoint) {\n        return;\n      }\n\n      animateToPosition(\n        destinationPoint,\n        ANIMATION_SOURCE.GESTURE,\n        velocityY / 2\n      );\n    },\n    [\n      enablePanDownToClose,\n      isInTemporaryPosition,\n      isScrollableRefreshable,\n      animatedClosedPosition,\n      animatedHighestSnapPoint,\n      animatedKeyboardHeight,\n      animatedPosition,\n      animatedScrollableType,\n      animatedSnapPoints,\n      animatedScrollableContentOffsetY,\n      animateToPosition,\n    ]\n  );\n  const handleOnFinalize: GestureEventHandlerCallbackType = useWorkletCallback(\n    function handleOnFinalize() {\n      resetContext(context);\n    },\n    [context]\n  );\n  //#endregion\n\n  return {\n    handleOnStart,\n    handleOnChange,\n    handleOnEnd,\n    handleOnFinalize,\n  };\n};\n"],"mappings":"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"}