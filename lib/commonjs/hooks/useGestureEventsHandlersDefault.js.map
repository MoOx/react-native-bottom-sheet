{"version":3,"names":["INITIAL_CONTEXT","initialPosition","initialKeyboardState","KEYBOARD_STATE","UNDETERMINED","isScrollablePositionLocked","resetContext","context","Object","keys","map","key","undefined","useGestureEventsHandlersDefault","animatedPosition","animatedSnapPoints","animatedKeyboardState","animatedKeyboardHeight","animatedContainerHeight","animatedScrollableType","animatedHighestSnapPoint","animatedClosedPosition","animatedScrollableContentOffsetY","enableOverDrag","enablePanDownToClose","overDragResistanceFactor","isInTemporaryPosition","isScrollableRefreshable","animateToPosition","stopAnimation","useBottomSheetInternal","useSharedValue","handleOnStart","useWorkletCallback","__","_","value","handleOnChange","source","translationY","highestSnapPoint","SHOWN","lowestSnapPoint","GESTURE_SOURCE","CONTENT","negativeScrollableContentOffset","draggedPosition","accumulatedDraggedPosition","clampedPosition","clamp","HANDLE","SCROLLABLE_TYPE","VIEW","resistedPosition","Math","sqrt","handleOnEnd","absoluteY","velocityY","isSheetAtHighestSnapPoint","ANIMATION_SOURCE","GESTURE","isScrollable","Platform","OS","WINDOW_HEIGHT","runOnJS","Keyboard","dismiss","snapPoints","slice","unshift","destinationPoint","snapPoint","wasGestureHandledByScrollView","handleOnFinalize"],"sources":["useGestureEventsHandlersDefault.tsx"],"sourcesContent":["import { Keyboard, Platform } from 'react-native';\nimport {\n  runOnJS,\n  useSharedValue,\n  useWorkletCallback,\n} from 'react-native-reanimated';\nimport { useBottomSheetInternal } from './useBottomSheetInternal';\nimport {\n  ANIMATION_SOURCE,\n  GESTURE_SOURCE,\n  KEYBOARD_STATE,\n  SCROLLABLE_TYPE,\n  WINDOW_HEIGHT,\n} from '../constants';\nimport type {\n  GestureEventsHandlersHookType,\n  GestureEventHandlerCallbackType,\n} from '../types';\nimport { clamp } from '../utilities/clamp';\nimport { snapPoint } from '../utilities/snapPoint';\n\ntype GestureEventContextType = {\n  initialPosition: number;\n  initialKeyboardState: KEYBOARD_STATE;\n  isScrollablePositionLocked: boolean;\n};\n\nconst INITIAL_CONTEXT: GestureEventContextType = {\n  initialPosition: 0,\n  initialKeyboardState: KEYBOARD_STATE.UNDETERMINED,\n  isScrollablePositionLocked: false,\n};\n\nconst resetContext = (context: any) => {\n  'worklet';\n  Object.keys(context).map(key => {\n    context[key] = undefined;\n  });\n};\n\nexport const useGestureEventsHandlersDefault: GestureEventsHandlersHookType =\n  () => {\n    //#region variables\n    const {\n      animatedPosition,\n      animatedSnapPoints,\n      animatedKeyboardState,\n      animatedKeyboardHeight,\n      animatedContainerHeight,\n      animatedScrollableType,\n      animatedHighestSnapPoint,\n      animatedClosedPosition,\n      animatedScrollableContentOffsetY,\n      enableOverDrag,\n      enablePanDownToClose,\n      overDragResistanceFactor,\n      isInTemporaryPosition,\n      isScrollableRefreshable,\n      animateToPosition,\n      stopAnimation,\n    } = useBottomSheetInternal();\n\n    const context = useSharedValue<GestureEventContextType>({\n      ...INITIAL_CONTEXT,\n    });\n    //#endregion\n\n    //#region gesture methods\n    const handleOnStart: GestureEventHandlerCallbackType = useWorkletCallback(\n      function handleOnStart(__, _) {\n        // cancel current animation\n        stopAnimation();\n\n        // store current animated position\n        context.value = {\n          ...context.value,\n          initialPosition: animatedPosition.value,\n          initialKeyboardState: animatedKeyboardState.value,\n        };\n\n        /**\n         * if the scrollable content is scrolled, then\n         * we lock the position.\n         */\n        if (animatedScrollableContentOffsetY.value > 0) {\n          context.value = {\n            ...context.value,\n            isScrollablePositionLocked: true,\n          };\n        }\n      },\n      [\n        stopAnimation,\n        animatedPosition,\n        animatedKeyboardState,\n        animatedScrollableContentOffsetY,\n      ]\n    );\n    const handleOnChange: GestureEventHandlerCallbackType = useWorkletCallback(\n      function handleOnChange(source, { translationY }) {\n        let highestSnapPoint = animatedHighestSnapPoint.value;\n\n        /**\n         * if keyboard is shown, then we set the highest point to the current\n         * position which includes the keyboard height.\n         */\n        if (\n          isInTemporaryPosition.value &&\n          context.value.initialKeyboardState === KEYBOARD_STATE.SHOWN\n        ) {\n          highestSnapPoint = context.value.initialPosition;\n        }\n\n        /**\n         * if current position is out of provided `snapPoints` and smaller then\n         * highest snap pont, then we set the highest point to the current position.\n         */\n        if (\n          isInTemporaryPosition.value &&\n          context.value.initialPosition < highestSnapPoint\n        ) {\n          highestSnapPoint = context.value.initialPosition;\n        }\n\n        const lowestSnapPoint = enablePanDownToClose\n          ? animatedContainerHeight.value\n          : animatedSnapPoints.value[0];\n\n        /**\n         * if scrollable is refreshable and sheet position at the highest\n         * point, then do not interact with current gesture.\n         */\n        if (\n          source === GESTURE_SOURCE.CONTENT &&\n          isScrollableRefreshable.value &&\n          animatedPosition.value === highestSnapPoint\n        ) {\n          return;\n        }\n\n        /**\n         * a negative scrollable content offset to be subtracted from accumulated\n         * current position and gesture translation Y to allow user to drag the sheet,\n         * when scrollable position at the top.\n         * a negative scrollable content offset when the scrollable is not locked.\n         */\n        const negativeScrollableContentOffset =\n          (context.value.initialPosition === highestSnapPoint &&\n            source === GESTURE_SOURCE.CONTENT) ||\n          !context.value.isScrollablePositionLocked\n            ? animatedScrollableContentOffsetY.value * -1\n            : 0;\n\n        /**\n         * an accumulated value of starting position with gesture translation y.\n         */\n        const draggedPosition = context.value.initialPosition + translationY;\n\n        /**\n         * an accumulated value of dragged position and negative scrollable content offset,\n         * this will insure locking sheet position when user is scrolling the scrollable until,\n         * they reach to the top of the scrollable.\n         */\n        const accumulatedDraggedPosition =\n          draggedPosition + negativeScrollableContentOffset;\n\n        /**\n         * a clamped value of the accumulated dragged position, to insure keeping the dragged\n         * position between the highest and lowest snap points.\n         */\n        const clampedPosition = clamp(\n          accumulatedDraggedPosition,\n          highestSnapPoint,\n          lowestSnapPoint\n        );\n\n        /**\n         * if scrollable position is locked and the animated position\n         * reaches the highest point, then we unlock the scrollable position.\n         */\n        if (\n          context.value.isScrollablePositionLocked &&\n          source === GESTURE_SOURCE.CONTENT &&\n          animatedPosition.value === highestSnapPoint\n        ) {\n          context.value = {\n            ...context.value,\n            isScrollablePositionLocked: false,\n          };\n        }\n\n        /**\n         * over-drag implementation.\n         */\n        if (enableOverDrag) {\n          if (\n            (source === GESTURE_SOURCE.HANDLE ||\n              animatedScrollableType.value === SCROLLABLE_TYPE.VIEW) &&\n            draggedPosition < highestSnapPoint\n          ) {\n            const resistedPosition =\n              highestSnapPoint -\n              Math.sqrt(1 + (highestSnapPoint - draggedPosition)) *\n                overDragResistanceFactor;\n            animatedPosition.value = resistedPosition;\n            return;\n          }\n\n          if (\n            source === GESTURE_SOURCE.HANDLE &&\n            draggedPosition > lowestSnapPoint\n          ) {\n            const resistedPosition =\n              lowestSnapPoint +\n              Math.sqrt(1 + (draggedPosition - lowestSnapPoint)) *\n                overDragResistanceFactor;\n            animatedPosition.value = resistedPosition;\n            return;\n          }\n\n          if (\n            source === GESTURE_SOURCE.CONTENT &&\n            draggedPosition + negativeScrollableContentOffset > lowestSnapPoint\n          ) {\n            const resistedPosition =\n              lowestSnapPoint +\n              Math.sqrt(\n                1 +\n                  (draggedPosition +\n                    negativeScrollableContentOffset -\n                    lowestSnapPoint)\n              ) *\n                overDragResistanceFactor;\n            animatedPosition.value = resistedPosition;\n            return;\n          }\n        }\n\n        animatedPosition.value = clampedPosition;\n      },\n      [\n        enableOverDrag,\n        enablePanDownToClose,\n        overDragResistanceFactor,\n        isInTemporaryPosition,\n        isScrollableRefreshable,\n        animatedHighestSnapPoint,\n        animatedContainerHeight,\n        animatedSnapPoints,\n        animatedPosition,\n        animatedScrollableType,\n        animatedScrollableContentOffsetY,\n      ]\n    );\n    const handleOnEnd: GestureEventHandlerCallbackType = useWorkletCallback(\n      function handleOnEnd(source, { translationY, absoluteY, velocityY }) {\n        const highestSnapPoint = animatedHighestSnapPoint.value;\n        const isSheetAtHighestSnapPoint =\n          animatedPosition.value === highestSnapPoint;\n\n        /**\n         * if scrollable is refreshable and sheet position at the highest\n         * point, then do not interact with current gesture.\n         */\n        if (\n          source === GESTURE_SOURCE.CONTENT &&\n          isScrollableRefreshable.value &&\n          isSheetAtHighestSnapPoint\n        ) {\n          return;\n        }\n\n        /**\n         * if the sheet is in a temporary position and the gesture ended above\n         * the current position, then we snap back to the temporary position.\n         */\n        if (\n          isInTemporaryPosition.value &&\n          context.value.initialPosition >= animatedPosition.value\n        ) {\n          if (context.value.initialPosition > animatedPosition.value) {\n            animateToPosition(\n              context.value.initialPosition,\n              ANIMATION_SOURCE.GESTURE,\n              velocityY / 2\n            );\n          }\n          return;\n        }\n\n        /**\n         * close keyboard if current position is below the recorded\n         * start position and keyboard still shown.\n         */\n        const isScrollable =\n          animatedScrollableType.value !== SCROLLABLE_TYPE.UNDETERMINED &&\n          animatedScrollableType.value !== SCROLLABLE_TYPE.VIEW;\n\n        /**\n         * if keyboard is shown and the sheet is dragged down,\n         * then we dismiss the keyboard.\n         */\n        if (\n          context.value.initialKeyboardState === KEYBOARD_STATE.SHOWN &&\n          animatedPosition.value > context.value.initialPosition\n        ) {\n          /**\n           * if the platform is ios, current content is scrollable and\n           * the end touch point is below the keyboard position then\n           * we exit the method.\n           *\n           * because the the keyboard dismiss is interactive in iOS.\n           */\n          if (\n            !(\n              Platform.OS === 'ios' &&\n              isScrollable &&\n              absoluteY > WINDOW_HEIGHT - animatedKeyboardHeight.value\n            )\n          ) {\n            runOnJS(Keyboard.dismiss)();\n          }\n        }\n\n        /**\n         * reset isInTemporaryPosition value\n         */\n        if (isInTemporaryPosition.value) {\n          isInTemporaryPosition.value = false;\n        }\n\n        /**\n         * clone snap points array, and insert the container height\n         * if pan down to close is enabled.\n         */\n        const snapPoints = animatedSnapPoints.value.slice();\n        if (enablePanDownToClose) {\n          snapPoints.unshift(animatedClosedPosition.value);\n        }\n\n        /**\n         * calculate the destination point, using redash.\n         */\n        const destinationPoint = snapPoint(\n          translationY + context.value.initialPosition,\n          velocityY,\n          snapPoints\n        );\n\n        /**\n         * if destination point is the same as the current position,\n         * then no need to perform animation.\n         */\n        if (destinationPoint === animatedPosition.value) {\n          return;\n        }\n\n        const wasGestureHandledByScrollView =\n          source === GESTURE_SOURCE.CONTENT &&\n          animatedScrollableContentOffsetY.value > 0;\n        /**\n         * prevents snapping from top to middle / bottom with repeated interrupted scrolls\n         */\n        if (wasGestureHandledByScrollView && isSheetAtHighestSnapPoint) {\n          return;\n        }\n\n        animateToPosition(\n          destinationPoint,\n          ANIMATION_SOURCE.GESTURE,\n          velocityY / 2\n        );\n      },\n      [\n        enablePanDownToClose,\n        isInTemporaryPosition,\n        isScrollableRefreshable,\n        animatedClosedPosition,\n        animatedHighestSnapPoint,\n        animatedKeyboardHeight,\n        animatedPosition,\n        animatedScrollableType,\n        animatedSnapPoints,\n        animatedScrollableContentOffsetY,\n        animateToPosition,\n      ]\n    );\n\n    const handleOnFinalize: GestureEventHandlerCallbackType =\n      useWorkletCallback(\n        function handleOnFinalize() {\n          resetContext(context);\n        },\n        [context]\n      );\n    //#endregion\n\n    return {\n      handleOnStart,\n      handleOnChange,\n      handleOnEnd,\n      handleOnFinalize,\n    };\n  };\n"],"mappings":"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"}