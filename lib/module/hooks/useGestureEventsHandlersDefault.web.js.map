{"version":3,"names":["Keyboard","Platform","runOnJS","useSharedValue","useWorkletCallback","useBottomSheetInternal","ANIMATION_SOURCE","GESTURE_SOURCE","KEYBOARD_STATE","SCROLLABLE_TYPE","WINDOW_HEIGHT","clamp","snapPoint","INITIAL_CONTEXT","initialPosition","initialTranslationY","initialKeyboardState","UNDETERMINED","isScrollablePositionLocked","resetContext","context","Object","keys","map","key","undefined","useGestureEventsHandlersDefault","animatedPosition","animatedSnapPoints","animatedKeyboardState","animatedKeyboardHeight","animatedContainerHeight","animatedScrollableType","animatedHighestSnapPoint","animatedClosedPosition","animatedScrollableContentOffsetY","enableOverDrag","enablePanDownToClose","overDragResistanceFactor","isInTemporaryPosition","isScrollableRefreshable","animateToPosition","stopAnimation","handleOnStart","__","translationY","value","handleOnChange","source","highestSnapPoint","SHOWN","lowestSnapPoint","CONTENT","negativeScrollableContentOffset","draggedPosition","accumulatedDraggedPosition","clampedPosition","HANDLE","VIEW","resistedPosition","Math","sqrt","handleOnEnd","absoluteY","velocityY","isSheetAtHighestSnapPoint","GESTURE","isScrollable","OS","dismiss","snapPoints","slice","unshift","destinationPoint","wasGestureHandledByScrollView","handleOnFinalize"],"sources":["useGestureEventsHandlersDefault.web.tsx"],"sourcesContent":["import { Keyboard, Platform } from 'react-native';\nimport {\n  runOnJS,\n  useSharedValue,\n  useWorkletCallback,\n} from 'react-native-reanimated';\nimport { useBottomSheetInternal } from './useBottomSheetInternal';\nimport {\n  ANIMATION_SOURCE,\n  GESTURE_SOURCE,\n  KEYBOARD_STATE,\n  SCROLLABLE_TYPE,\n  WINDOW_HEIGHT,\n} from '../constants';\nimport type { GestureEventHandlerCallbackType } from '../types';\nimport { clamp } from '../utilities/clamp';\nimport { snapPoint } from '../utilities/snapPoint';\n\ntype GestureEventContextType = {\n  initialPosition: number;\n  initialKeyboardState: KEYBOARD_STATE;\n  initialTranslationY: number;\n  isScrollablePositionLocked: boolean;\n};\n\nconst INITIAL_CONTEXT: GestureEventContextType = {\n  initialPosition: 0,\n  initialTranslationY: 0,\n  initialKeyboardState: KEYBOARD_STATE.UNDETERMINED,\n  isScrollablePositionLocked: false,\n};\n\nconst resetContext = (context: any) => {\n  'worklet';\n  Object.keys(context).map(key => {\n    context[key] = undefined;\n  });\n};\n\nexport const useGestureEventsHandlersDefault = () => {\n  //#region variables\n  const {\n    animatedPosition,\n    animatedSnapPoints,\n    animatedKeyboardState,\n    animatedKeyboardHeight,\n    animatedContainerHeight,\n    animatedScrollableType,\n    animatedHighestSnapPoint,\n    animatedClosedPosition,\n    animatedScrollableContentOffsetY,\n    enableOverDrag,\n    enablePanDownToClose,\n    overDragResistanceFactor,\n    isInTemporaryPosition,\n    isScrollableRefreshable,\n    animateToPosition,\n    stopAnimation,\n  } = useBottomSheetInternal();\n\n  const context = useSharedValue<GestureEventContextType>({\n    ...INITIAL_CONTEXT,\n  });\n  //#endregion\n\n  //#region gesture methods\n  const handleOnStart: GestureEventHandlerCallbackType = useWorkletCallback(\n    function handleOnStart(__, { translationY }) {\n      // cancel current animation\n      stopAnimation();\n\n      // store current animated position\n      context.value = {\n        ...context.value,\n        initialPosition: animatedPosition.value,\n        initialKeyboardState: animatedKeyboardState.value,\n        initialTranslationY: translationY,\n      };\n\n      /**\n       * if the scrollable content is scrolled, then\n       * we lock the position.\n       */\n      if (animatedScrollableContentOffsetY.value > 0) {\n        context.value.isScrollablePositionLocked = true;\n      }\n    },\n    [\n      stopAnimation,\n      animatedPosition,\n      animatedKeyboardState,\n      animatedScrollableContentOffsetY,\n    ]\n  );\n  const handleOnChange: GestureEventHandlerCallbackType = useWorkletCallback(\n    function handleOnChange(source, { translationY }) {\n      let highestSnapPoint = animatedHighestSnapPoint.value;\n\n      translationY = translationY - context.value.initialTranslationY;\n      /**\n       * if keyboard is shown, then we set the highest point to the current\n       * position which includes the keyboard height.\n       */\n      if (\n        isInTemporaryPosition.value &&\n        context.value.initialKeyboardState === KEYBOARD_STATE.SHOWN\n      ) {\n        highestSnapPoint = context.value.initialPosition;\n      }\n\n      /**\n       * if current position is out of provided `snapPoints` and smaller then\n       * highest snap pont, then we set the highest point to the current position.\n       */\n      if (\n        isInTemporaryPosition.value &&\n        context.value.initialPosition < highestSnapPoint\n      ) {\n        highestSnapPoint = context.value.initialPosition;\n      }\n\n      const lowestSnapPoint = enablePanDownToClose\n        ? animatedContainerHeight.value\n        : animatedSnapPoints.value[0];\n\n      /**\n       * if scrollable is refreshable and sheet position at the highest\n       * point, then do not interact with current gesture.\n       */\n      if (\n        source === GESTURE_SOURCE.CONTENT &&\n        isScrollableRefreshable.value &&\n        animatedPosition.value === highestSnapPoint\n      ) {\n        return;\n      }\n\n      /**\n       * a negative scrollable content offset to be subtracted from accumulated\n       * current position and gesture translation Y to allow user to drag the sheet,\n       * when scrollable position at the top.\n       * a negative scrollable content offset when the scrollable is not locked.\n       */\n      const negativeScrollableContentOffset =\n        (context.value.initialPosition === highestSnapPoint &&\n          source === GESTURE_SOURCE.CONTENT) ||\n        !context.value.isScrollablePositionLocked\n          ? animatedScrollableContentOffsetY.value * -1\n          : 0;\n\n      /**\n       * an accumulated value of starting position with gesture translation y.\n       */\n      const draggedPosition = context.value.initialPosition + translationY;\n\n      /**\n       * an accumulated value of dragged position and negative scrollable content offset,\n       * this will insure locking sheet position when user is scrolling the scrollable until,\n       * they reach to the top of the scrollable.\n       */\n      const accumulatedDraggedPosition =\n        draggedPosition + negativeScrollableContentOffset;\n\n      /**\n       * a clamped value of the accumulated dragged position, to insure keeping the dragged\n       * position between the highest and lowest snap points.\n       */\n      const clampedPosition = clamp(\n        accumulatedDraggedPosition,\n        highestSnapPoint,\n        lowestSnapPoint\n      );\n\n      /**\n       * if scrollable position is locked and the animated position\n       * reaches the highest point, then we unlock the scrollable position.\n       */\n      if (\n        context.value.isScrollablePositionLocked &&\n        source === GESTURE_SOURCE.CONTENT &&\n        animatedPosition.value === highestSnapPoint\n      ) {\n        context.value.isScrollablePositionLocked = false;\n      }\n\n      /**\n       * over-drag implementation.\n       */\n      if (enableOverDrag) {\n        if (\n          (source === GESTURE_SOURCE.HANDLE ||\n            animatedScrollableType.value === SCROLLABLE_TYPE.VIEW) &&\n          draggedPosition < highestSnapPoint\n        ) {\n          const resistedPosition =\n            highestSnapPoint -\n            Math.sqrt(1 + (highestSnapPoint - draggedPosition)) *\n              overDragResistanceFactor;\n          animatedPosition.value = resistedPosition;\n          return;\n        }\n\n        if (\n          source === GESTURE_SOURCE.HANDLE &&\n          draggedPosition > lowestSnapPoint\n        ) {\n          const resistedPosition =\n            lowestSnapPoint +\n            Math.sqrt(1 + (draggedPosition - lowestSnapPoint)) *\n              overDragResistanceFactor;\n          animatedPosition.value = resistedPosition;\n          return;\n        }\n\n        if (\n          source === GESTURE_SOURCE.CONTENT &&\n          draggedPosition + negativeScrollableContentOffset > lowestSnapPoint\n        ) {\n          const resistedPosition =\n            lowestSnapPoint +\n            Math.sqrt(\n              1 +\n                (draggedPosition +\n                  negativeScrollableContentOffset -\n                  lowestSnapPoint)\n            ) *\n              overDragResistanceFactor;\n          animatedPosition.value = resistedPosition;\n          return;\n        }\n      }\n\n      animatedPosition.value = clampedPosition;\n    },\n    [\n      enableOverDrag,\n      enablePanDownToClose,\n      overDragResistanceFactor,\n      isInTemporaryPosition,\n      isScrollableRefreshable,\n      animatedHighestSnapPoint,\n      animatedContainerHeight,\n      animatedSnapPoints,\n      animatedPosition,\n      animatedScrollableType,\n      animatedScrollableContentOffsetY,\n    ]\n  );\n  const handleOnEnd: GestureEventHandlerCallbackType = useWorkletCallback(\n    function handleOnEnd(source, { translationY, absoluteY, velocityY }) {\n      const highestSnapPoint = animatedHighestSnapPoint.value;\n      const isSheetAtHighestSnapPoint =\n        animatedPosition.value === highestSnapPoint;\n\n      /**\n       * if scrollable is refreshable and sheet position at the highest\n       * point, then do not interact with current gesture.\n       */\n      if (\n        source === GESTURE_SOURCE.CONTENT &&\n        isScrollableRefreshable.value &&\n        isSheetAtHighestSnapPoint\n      ) {\n        return;\n      }\n\n      /**\n       * if the sheet is in a temporary position and the gesture ended above\n       * the current position, then we snap back to the temporary position.\n       */\n      if (\n        isInTemporaryPosition.value &&\n        context.value.initialPosition >= animatedPosition.value\n      ) {\n        if (context.value.initialPosition > animatedPosition.value) {\n          animateToPosition(\n            context.value.initialPosition,\n            ANIMATION_SOURCE.GESTURE,\n            velocityY / 2\n          );\n        }\n        return;\n      }\n\n      /**\n       * close keyboard if current position is below the recorded\n       * start position and keyboard still shown.\n       */\n      const isScrollable =\n        animatedScrollableType.value !== SCROLLABLE_TYPE.UNDETERMINED &&\n        animatedScrollableType.value !== SCROLLABLE_TYPE.VIEW;\n\n      /**\n       * if keyboard is shown and the sheet is dragged down,\n       * then we dismiss the keyboard.\n       */\n      if (\n        context.value.initialKeyboardState === KEYBOARD_STATE.SHOWN &&\n        animatedPosition.value > context.value.initialPosition\n      ) {\n        /**\n         * if the platform is ios, current content is scrollable and\n         * the end touch point is below the keyboard position then\n         * we exit the method.\n         *\n         * because the the keyboard dismiss is interactive in iOS.\n         */\n        if (\n          !(\n            Platform.OS === 'ios' &&\n            isScrollable &&\n            absoluteY > WINDOW_HEIGHT - animatedKeyboardHeight.value\n          )\n        ) {\n          runOnJS(Keyboard.dismiss)();\n        }\n      }\n\n      /**\n       * reset isInTemporaryPosition value\n       */\n      if (isInTemporaryPosition.value) {\n        isInTemporaryPosition.value = false;\n      }\n\n      /**\n       * clone snap points array, and insert the container height\n       * if pan down to close is enabled.\n       */\n      const snapPoints = animatedSnapPoints.value.slice();\n      if (enablePanDownToClose) {\n        snapPoints.unshift(animatedClosedPosition.value);\n      }\n\n      /**\n       * calculate the destination point, using redash.\n       */\n      const destinationPoint = snapPoint(\n        translationY + context.value.initialPosition,\n        velocityY,\n        snapPoints\n      );\n\n      /**\n       * if destination point is the same as the current position,\n       * then no need to perform animation.\n       */\n      if (destinationPoint === animatedPosition.value) {\n        return;\n      }\n\n      const wasGestureHandledByScrollView =\n        source === GESTURE_SOURCE.CONTENT &&\n        animatedScrollableContentOffsetY.value > 0;\n      /**\n       * prevents snapping from top to middle / bottom with repeated interrupted scrolls\n       */\n      if (wasGestureHandledByScrollView && isSheetAtHighestSnapPoint) {\n        return;\n      }\n\n      animateToPosition(\n        destinationPoint,\n        ANIMATION_SOURCE.GESTURE,\n        velocityY / 2\n      );\n    },\n    [\n      enablePanDownToClose,\n      isInTemporaryPosition,\n      isScrollableRefreshable,\n      animatedClosedPosition,\n      animatedHighestSnapPoint,\n      animatedKeyboardHeight,\n      animatedPosition,\n      animatedScrollableType,\n      animatedSnapPoints,\n      animatedScrollableContentOffsetY,\n      animateToPosition,\n    ]\n  );\n  const handleOnFinalize: GestureEventHandlerCallbackType = useWorkletCallback(\n    function handleOnFinalize() {\n      resetContext(context);\n    },\n    [context]\n  );\n  //#endregion\n\n  return {\n    handleOnStart,\n    handleOnChange,\n    handleOnEnd,\n    handleOnFinalize,\n  };\n};\n"],"mappings":"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"}