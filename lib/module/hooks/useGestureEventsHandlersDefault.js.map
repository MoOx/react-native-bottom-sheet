{"version":3,"names":["Keyboard","Platform","runOnJS","useSharedValue","useWorkletCallback","useBottomSheetInternal","ANIMATION_SOURCE","GESTURE_SOURCE","KEYBOARD_STATE","SCROLLABLE_TYPE","WINDOW_HEIGHT","clamp","snapPoint","INITIAL_CONTEXT","initialPosition","initialKeyboardState","UNDETERMINED","isScrollablePositionLocked","resetContext","context","Object","keys","map","key","undefined","useGestureEventsHandlersDefault","animatedPosition","animatedSnapPoints","animatedKeyboardState","animatedKeyboardHeight","animatedContainerHeight","animatedScrollableType","animatedHighestSnapPoint","animatedClosedPosition","animatedScrollableContentOffsetY","enableOverDrag","enablePanDownToClose","overDragResistanceFactor","isInTemporaryPosition","isScrollableRefreshable","animateToPosition","stopAnimation","handleOnStart","__","_","value","handleOnChange","source","translationY","highestSnapPoint","SHOWN","lowestSnapPoint","CONTENT","negativeScrollableContentOffset","draggedPosition","accumulatedDraggedPosition","clampedPosition","HANDLE","VIEW","resistedPosition","Math","sqrt","handleOnEnd","absoluteY","velocityY","isSheetAtHighestSnapPoint","GESTURE","isScrollable","OS","dismiss","snapPoints","slice","unshift","destinationPoint","wasGestureHandledByScrollView","handleOnFinalize"],"sources":["useGestureEventsHandlersDefault.tsx"],"sourcesContent":["import { Keyboard, Platform } from 'react-native';\nimport {\n  runOnJS,\n  useSharedValue,\n  useWorkletCallback,\n} from 'react-native-reanimated';\nimport { useBottomSheetInternal } from './useBottomSheetInternal';\nimport {\n  ANIMATION_SOURCE,\n  GESTURE_SOURCE,\n  KEYBOARD_STATE,\n  SCROLLABLE_TYPE,\n  WINDOW_HEIGHT,\n} from '../constants';\nimport type {\n  GestureEventsHandlersHookType,\n  GestureEventHandlerCallbackType,\n} from '../types';\nimport { clamp } from '../utilities/clamp';\nimport { snapPoint } from '../utilities/snapPoint';\n\ntype GestureEventContextType = {\n  initialPosition: number;\n  initialKeyboardState: KEYBOARD_STATE;\n  isScrollablePositionLocked: boolean;\n};\n\nconst INITIAL_CONTEXT: GestureEventContextType = {\n  initialPosition: 0,\n  initialKeyboardState: KEYBOARD_STATE.UNDETERMINED,\n  isScrollablePositionLocked: false,\n};\n\nconst resetContext = (context: any) => {\n  'worklet';\n  Object.keys(context).map(key => {\n    context[key] = undefined;\n  });\n};\n\nexport const useGestureEventsHandlersDefault: GestureEventsHandlersHookType =\n  () => {\n    //#region variables\n    const {\n      animatedPosition,\n      animatedSnapPoints,\n      animatedKeyboardState,\n      animatedKeyboardHeight,\n      animatedContainerHeight,\n      animatedScrollableType,\n      animatedHighestSnapPoint,\n      animatedClosedPosition,\n      animatedScrollableContentOffsetY,\n      enableOverDrag,\n      enablePanDownToClose,\n      overDragResistanceFactor,\n      isInTemporaryPosition,\n      isScrollableRefreshable,\n      animateToPosition,\n      stopAnimation,\n    } = useBottomSheetInternal();\n\n    const context = useSharedValue<GestureEventContextType>({\n      ...INITIAL_CONTEXT,\n    });\n    //#endregion\n\n    //#region gesture methods\n    const handleOnStart: GestureEventHandlerCallbackType = useWorkletCallback(\n      function handleOnStart(__, _) {\n        // cancel current animation\n        stopAnimation();\n\n        // store current animated position\n        context.value = {\n          ...context.value,\n          initialPosition: animatedPosition.value,\n          initialKeyboardState: animatedKeyboardState.value,\n        };\n\n        /**\n         * if the scrollable content is scrolled, then\n         * we lock the position.\n         */\n        if (animatedScrollableContentOffsetY.value > 0) {\n          context.value = {\n            ...context.value,\n            isScrollablePositionLocked: true,\n          };\n        }\n      },\n      [\n        stopAnimation,\n        animatedPosition,\n        animatedKeyboardState,\n        animatedScrollableContentOffsetY,\n      ]\n    );\n    const handleOnChange: GestureEventHandlerCallbackType = useWorkletCallback(\n      function handleOnChange(source, { translationY }) {\n        let highestSnapPoint = animatedHighestSnapPoint.value;\n\n        /**\n         * if keyboard is shown, then we set the highest point to the current\n         * position which includes the keyboard height.\n         */\n        if (\n          isInTemporaryPosition.value &&\n          context.value.initialKeyboardState === KEYBOARD_STATE.SHOWN\n        ) {\n          highestSnapPoint = context.value.initialPosition;\n        }\n\n        /**\n         * if current position is out of provided `snapPoints` and smaller then\n         * highest snap pont, then we set the highest point to the current position.\n         */\n        if (\n          isInTemporaryPosition.value &&\n          context.value.initialPosition < highestSnapPoint\n        ) {\n          highestSnapPoint = context.value.initialPosition;\n        }\n\n        const lowestSnapPoint = enablePanDownToClose\n          ? animatedContainerHeight.value\n          : animatedSnapPoints.value[0];\n\n        /**\n         * if scrollable is refreshable and sheet position at the highest\n         * point, then do not interact with current gesture.\n         */\n        if (\n          source === GESTURE_SOURCE.CONTENT &&\n          isScrollableRefreshable.value &&\n          animatedPosition.value === highestSnapPoint\n        ) {\n          return;\n        }\n\n        /**\n         * a negative scrollable content offset to be subtracted from accumulated\n         * current position and gesture translation Y to allow user to drag the sheet,\n         * when scrollable position at the top.\n         * a negative scrollable content offset when the scrollable is not locked.\n         */\n        const negativeScrollableContentOffset =\n          (context.value.initialPosition === highestSnapPoint &&\n            source === GESTURE_SOURCE.CONTENT) ||\n          !context.value.isScrollablePositionLocked\n            ? animatedScrollableContentOffsetY.value * -1\n            : 0;\n\n        /**\n         * an accumulated value of starting position with gesture translation y.\n         */\n        const draggedPosition = context.value.initialPosition + translationY;\n\n        /**\n         * an accumulated value of dragged position and negative scrollable content offset,\n         * this will insure locking sheet position when user is scrolling the scrollable until,\n         * they reach to the top of the scrollable.\n         */\n        const accumulatedDraggedPosition =\n          draggedPosition + negativeScrollableContentOffset;\n\n        /**\n         * a clamped value of the accumulated dragged position, to insure keeping the dragged\n         * position between the highest and lowest snap points.\n         */\n        const clampedPosition = clamp(\n          accumulatedDraggedPosition,\n          highestSnapPoint,\n          lowestSnapPoint\n        );\n\n        /**\n         * if scrollable position is locked and the animated position\n         * reaches the highest point, then we unlock the scrollable position.\n         */\n        if (\n          context.value.isScrollablePositionLocked &&\n          source === GESTURE_SOURCE.CONTENT &&\n          animatedPosition.value === highestSnapPoint\n        ) {\n          context.value = {\n            ...context.value,\n            isScrollablePositionLocked: false,\n          };\n        }\n\n        /**\n         * over-drag implementation.\n         */\n        if (enableOverDrag) {\n          if (\n            (source === GESTURE_SOURCE.HANDLE ||\n              animatedScrollableType.value === SCROLLABLE_TYPE.VIEW) &&\n            draggedPosition < highestSnapPoint\n          ) {\n            const resistedPosition =\n              highestSnapPoint -\n              Math.sqrt(1 + (highestSnapPoint - draggedPosition)) *\n                overDragResistanceFactor;\n            animatedPosition.value = resistedPosition;\n            return;\n          }\n\n          if (\n            source === GESTURE_SOURCE.HANDLE &&\n            draggedPosition > lowestSnapPoint\n          ) {\n            const resistedPosition =\n              lowestSnapPoint +\n              Math.sqrt(1 + (draggedPosition - lowestSnapPoint)) *\n                overDragResistanceFactor;\n            animatedPosition.value = resistedPosition;\n            return;\n          }\n\n          if (\n            source === GESTURE_SOURCE.CONTENT &&\n            draggedPosition + negativeScrollableContentOffset > lowestSnapPoint\n          ) {\n            const resistedPosition =\n              lowestSnapPoint +\n              Math.sqrt(\n                1 +\n                  (draggedPosition +\n                    negativeScrollableContentOffset -\n                    lowestSnapPoint)\n              ) *\n                overDragResistanceFactor;\n            animatedPosition.value = resistedPosition;\n            return;\n          }\n        }\n\n        animatedPosition.value = clampedPosition;\n      },\n      [\n        enableOverDrag,\n        enablePanDownToClose,\n        overDragResistanceFactor,\n        isInTemporaryPosition,\n        isScrollableRefreshable,\n        animatedHighestSnapPoint,\n        animatedContainerHeight,\n        animatedSnapPoints,\n        animatedPosition,\n        animatedScrollableType,\n        animatedScrollableContentOffsetY,\n      ]\n    );\n    const handleOnEnd: GestureEventHandlerCallbackType = useWorkletCallback(\n      function handleOnEnd(source, { translationY, absoluteY, velocityY }) {\n        const highestSnapPoint = animatedHighestSnapPoint.value;\n        const isSheetAtHighestSnapPoint =\n          animatedPosition.value === highestSnapPoint;\n\n        /**\n         * if scrollable is refreshable and sheet position at the highest\n         * point, then do not interact with current gesture.\n         */\n        if (\n          source === GESTURE_SOURCE.CONTENT &&\n          isScrollableRefreshable.value &&\n          isSheetAtHighestSnapPoint\n        ) {\n          return;\n        }\n\n        /**\n         * if the sheet is in a temporary position and the gesture ended above\n         * the current position, then we snap back to the temporary position.\n         */\n        if (\n          isInTemporaryPosition.value &&\n          context.value.initialPosition >= animatedPosition.value\n        ) {\n          if (context.value.initialPosition > animatedPosition.value) {\n            animateToPosition(\n              context.value.initialPosition,\n              ANIMATION_SOURCE.GESTURE,\n              velocityY / 2\n            );\n          }\n          return;\n        }\n\n        /**\n         * close keyboard if current position is below the recorded\n         * start position and keyboard still shown.\n         */\n        const isScrollable =\n          animatedScrollableType.value !== SCROLLABLE_TYPE.UNDETERMINED &&\n          animatedScrollableType.value !== SCROLLABLE_TYPE.VIEW;\n\n        /**\n         * if keyboard is shown and the sheet is dragged down,\n         * then we dismiss the keyboard.\n         */\n        if (\n          context.value.initialKeyboardState === KEYBOARD_STATE.SHOWN &&\n          animatedPosition.value > context.value.initialPosition\n        ) {\n          /**\n           * if the platform is ios, current content is scrollable and\n           * the end touch point is below the keyboard position then\n           * we exit the method.\n           *\n           * because the the keyboard dismiss is interactive in iOS.\n           */\n          if (\n            !(\n              Platform.OS === 'ios' &&\n              isScrollable &&\n              absoluteY > WINDOW_HEIGHT - animatedKeyboardHeight.value\n            )\n          ) {\n            runOnJS(Keyboard.dismiss)();\n          }\n        }\n\n        /**\n         * reset isInTemporaryPosition value\n         */\n        if (isInTemporaryPosition.value) {\n          isInTemporaryPosition.value = false;\n        }\n\n        /**\n         * clone snap points array, and insert the container height\n         * if pan down to close is enabled.\n         */\n        const snapPoints = animatedSnapPoints.value.slice();\n        if (enablePanDownToClose) {\n          snapPoints.unshift(animatedClosedPosition.value);\n        }\n\n        /**\n         * calculate the destination point, using redash.\n         */\n        const destinationPoint = snapPoint(\n          translationY + context.value.initialPosition,\n          velocityY,\n          snapPoints\n        );\n\n        /**\n         * if destination point is the same as the current position,\n         * then no need to perform animation.\n         */\n        if (destinationPoint === animatedPosition.value) {\n          return;\n        }\n\n        const wasGestureHandledByScrollView =\n          source === GESTURE_SOURCE.CONTENT &&\n          animatedScrollableContentOffsetY.value > 0;\n        /**\n         * prevents snapping from top to middle / bottom with repeated interrupted scrolls\n         */\n        if (wasGestureHandledByScrollView && isSheetAtHighestSnapPoint) {\n          return;\n        }\n\n        animateToPosition(\n          destinationPoint,\n          ANIMATION_SOURCE.GESTURE,\n          velocityY / 2\n        );\n      },\n      [\n        enablePanDownToClose,\n        isInTemporaryPosition,\n        isScrollableRefreshable,\n        animatedClosedPosition,\n        animatedHighestSnapPoint,\n        animatedKeyboardHeight,\n        animatedPosition,\n        animatedScrollableType,\n        animatedSnapPoints,\n        animatedScrollableContentOffsetY,\n        animateToPosition,\n      ]\n    );\n\n    const handleOnFinalize: GestureEventHandlerCallbackType =\n      useWorkletCallback(\n        function handleOnFinalize() {\n          resetContext(context);\n        },\n        [context]\n      );\n    //#endregion\n\n    return {\n      handleOnStart,\n      handleOnChange,\n      handleOnEnd,\n      handleOnFinalize,\n    };\n  };\n"],"mappings":"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"}